(()=>{"use strict";var t={d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Formula:()=>E});var r=Object.defineProperty,i=(t,e,i)=>(((t,e,i)=>{e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i})(t,"symbol"!=typeof e?e+"":e,i),i);const s={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class n{static throwIfNotNumber(t){if("string"==typeof t)throw new Error("Strings are not allowed in math operations")}}class o{static throwIfNotNumber(t){if("string"==typeof t)throw new Error("Strings are not allowed in math operations")}}class a{static createOperatorExpression(t,e,r){if("^"===t)return new c(e,r);if(["*","/"].includes(t))return new p(t,e,r);if(["+","-"].includes(t))return new u(t,e,r);if(["<",">","<=",">=","=","!="].includes(t))return new f(t,e,r);throw new Error(`Unknown operator: ${t}`)}evaluate(t={}){throw new Error("Empty Expression - Must be defined in child classes")}toString(){return""}}class h extends a{constructor(t){if(super(),i(this,"innerExpression"),this.innerExpression=t,!(this.innerExpression instanceof a))throw new Error("No inner expression given for bracket expression")}evaluate(t={}){return this.innerExpression.evaluate(t)}toString(){return`(${this.innerExpression.toString()})`}}class l extends a{constructor(t,e="number"){switch(super(),i(this,"value"),i(this,"type"),this.value=Number(t),e){case"number":if(this.value=Number(t),isNaN(this.value))throw new Error("Cannot parse number: "+t);break;case"string":this.value=String(t);break;default:throw new Error("Invalid value type: "+e)}this.type=e}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class u extends a{constructor(t,e,r){if(super(),i(this,"operator"),i(this,"left"),i(this,"right"),!["+","-"].includes(t))throw new Error(`Operator not allowed in Plus/Minus expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(n.throwIfNotNumber(e),n.throwIfNotNumber(r),"+"===this.operator)return Number(e)+Number(r);if("-"===this.operator)return Number(e)-Number(r);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class p extends a{constructor(t,e,r){if(super(),i(this,"operator"),i(this,"left"),i(this,"right"),!["*","/"].includes(t))throw new Error(`Operator not allowed in Multiply/Division expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(n.throwIfNotNumber(e),n.throwIfNotNumber(r),"*"===this.operator)return Number(e)*Number(r);if("/"===this.operator)return Number(e)/Number(r);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class c extends a{constructor(t,e){super(),i(this,"base"),i(this,"exponent"),this.base=t,this.exponent=e}evaluate(t={}){const e=this.base.evaluate(t),r=this.exponent.evaluate(t);return n.throwIfNotNumber(e),n.throwIfNotNumber(r),Math.pow(Number(e),Number(r))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class f extends a{constructor(t,e,r){if(super(),i(this,"operator"),i(this,"left"),i(this,"right"),!["<",">","<=",">=","=","!="].includes(t))throw new Error(`Operator not allowed in Logical expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);switch(this.operator){case"<":return e<r?1:0;case">":return e>r?1:0;case"<=":return e<=r?1:0;case">=":return e>=r?1:0;case"=":return e===r?1:0;case"!=":return e!==r?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class w extends a{constructor(t,e,r=null){super(),i(this,"fn"),i(this,"varPath"),i(this,"argumentExpressions"),i(this,"formulaObject"),i(this,"blacklisted"),this.fn=null!=t?t:"",this.varPath=this.fn.split("."),this.argumentExpressions=e||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(t={}){var e;t=t||{};const r=this.argumentExpressions.map((e=>e.evaluate(t)));try{let e=m(t,this.varPath,this.fn);if(e instanceof Function)return e.apply(this,r)}catch(t){}let i;try{i=m(null!=(e=this.formulaObject)?e:{},this.varPath,this.fn)}catch(t){}if(this.formulaObject&&i instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return i.apply(this.formulaObject,r)}try{const t=m(Math,this.varPath,this.fn);if(t instanceof Function)return r.forEach((t=>{o.throwIfNotNumber(t)})),t.apply(this,r)}catch(t){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map((t=>t.toString())).join(", ")})`}isBlacklisted(){return void 0===this.blacklisted&&(this.blacklisted=E.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function m(t,e,r){let i=t;for(let t of e){if("object"!=typeof i)throw new Error(`Cannot evaluate ${t}, property not found (from path ${r})`);if(void 0===i[t])throw new Error(`Cannot evaluate ${t}, property not found (from path ${r})`);i=i[t]}if("object"==typeof i)throw new Error("Invalid value");return i}class g extends a{constructor(t,e=null){super(),i(this,"fullPath"),i(this,"varPath"),i(this,"formulaObject"),this.formulaObject=e,this.fullPath=t,this.varPath=t.split(".")}evaluate(t={}){var e;let r;try{r=m(t,this.varPath,this.fullPath)}catch(t){}if(void 0===r&&(r=m(null!=(e=this.formulaObject)?e:{},this.varPath,this.fullPath)),"function"==typeof r||"object"==typeof r)throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return r}toString(){return`${this.varPath.join(".")}`}}const b=class t{constructor(t,e={}){i(this,"formulaExpression"),i(this,"options"),i(this,"formulaStr"),i(this,"_variables"),i(this,"_memory"),this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(t)}setFormula(t){return t&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=t,this.formulaExpression=this.parse(t)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(t){let e=0,r="";const i=[];for(let s of t.split(""))if(","===s&&0===e)i.push(r),r="";else if("("===s)e++,r+=s;else if(")"===s){if(e--,r+=s,e<0)throw new Error("ERROR: Too many closing parentheses!")}else r+=s;if(0!==e)throw new Error("ERROR: Too many opening parentheses!");return r.length>0&&i.push(r),i}cleanupInputFormula(t){const e=[];return t.split('"').forEach(((t,r)=>{r%2==0&&(t=t.replace(/[\s]+/g,""),Object.keys(s).forEach((e=>{t=t.replace(new RegExp(`\\b${e}\\b`,"g"),`[${e}]`)}))),e.push(t)})),e.join('"')}parse(t){return t=this.cleanupInputFormula(t),this._do_parse(t)}_do_parse(t){let e=t.length-1,r=0,i="initial",s=[],n="",o="",u=null,p=0,c="";for(;r<=e;){switch(i){case"initial":if(n=t.charAt(r),n.match(/[0-9.]/))i="within-nr",o="",r--;else if(this.isOperator(n)){if("-"===n&&(0===s.length||this.isOperatorExpr(s[s.length-1]))){i="within-nr",o="-";break}if(r===e||this.isOperatorExpr(s[s.length-1])){i="invalid";break}s.push(a.createOperatorExpression(n,new a,new a)),i="initial"}else if([">","<","=","!"].includes(n)){if(r===e){i="invalid";break}i="within-logical-operator",o=n}else"("===n?(i="within-parentheses",o="",p=0):"["===n?(i="within-named-var",o=""):n.match(/["']/)?(i="within-string",c=n,o=""):n.match(/[a-zA-Z]/)&&(r<e&&t.charAt(r+1).match(/[a-zA-Z0-9_.]/)?(o=n,i="within-func"):(s.length>0&&s[s.length-1]instanceof l&&s.push(a.createOperatorExpression("*",new a,new a)),s.push(new g(n,this)),this.registerVariable(n),i="initial",o=""));break;case"within-nr":n=t.charAt(r),n.match(/[0-9.]/)?(o+=n,r===e&&(s.push(new l(o)),i="initial")):("-"===o&&(o="-1"),s.push(new l(o)),o="",i="initial",r--);break;case"within-func":if(n=t.charAt(r),n.match(/[a-zA-Z0-9_.]/))o+=n;else{if("("!==n)throw new Error("Wrong character for function at position "+r);u=o,o="",p=0,i="within-func-parentheses"}break;case"within-named-var":if(n=t.charAt(r),"]"===n)s.push(new g(o,this)),this.registerVariable(o),o="",i="initial";else{if(!n.match(/[a-zA-Z0-9_.]/))throw new Error("Character not allowed within named variable: "+n);o+=n}break;case"within-string":n=t.charAt(r),n===c?(s.push(new l(o,"string")),o="",i="initial",c=""):o+=n;break;case"within-parentheses":case"within-func-parentheses":if(n=t.charAt(r),c)n===c&&(c=""),o+=n;else if(")"===n)if(p<=0){if("within-parentheses"===i)s.push(new h(this._do_parse(o)));else if("within-func-parentheses"===i){let t=this.splitFunctionParams(o).map((t=>this._do_parse(t)));s.push(new w(u,t,this)),u=null}i="initial"}else p--,o+=n;else"("===n?(p++,o+=n):(n.match(/["']/)&&(c=n),o+=n);break;case"within-logical-operator":n=t.charAt(r),"="===n&&(o+=n,r++),s.push(a.createOperatorExpression(o,new a,new a)),o="",i="initial",r--}r++}if("initial"!==i)throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(s)}buildExpressionTree(t){if(t.length<1)throw new Error("No expression given!");const e=[...t];let r=0,i=null;for(;r<e.length;)if(i=e[r],i instanceof c){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.base=e[r-1],i.exponent=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof p){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof u){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof f){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;if(1!==e.length)throw new Error("Could not parse formula: incorrect syntax?");return e[0]}isOperator(t){return"string"==typeof t&&t.match(/[+\-*/^]/)}isOperatorExpr(t){return t instanceof u||t instanceof p||t instanceof c||t instanceof f}registerVariable(t){this._variables.indexOf(t)<0&&this._variables.push(t)}getVariables(){return this._variables}evaluate(t){if(t instanceof Array)return t.map((t=>this.evaluate(t)));let e=this.getExpression();if(!(e instanceof a))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let r=this.resultFromMemory(t);return null!==r||(r=e.evaluate({...s,...t}),this.storeInMemory(t,r)),r}return e.evaluate({...s,...t})}hashValues(t){return JSON.stringify(t)}resultFromMemory(t){let e=this.hashValues(t),r=this._memory[e];return void 0!==r?r:null}storeInMemory(t,e){this._memory[this.hashValues(t)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(e,r=null,i={}){return r=null!=r?r:{},new t(e,i).evaluate(r)}};i(b,"Expression",a),i(b,"BracketExpression",h),i(b,"PowerExpression",c),i(b,"MultDivExpression",p),i(b,"PlusMinusExpression",u),i(b,"LogicalExpression",f),i(b,"ValueExpression",l),i(b,"VariableExpression",g),i(b,"FunctionExpression",w),i(b,"MATH_CONSTANTS",s),i(b,"functionBlacklist",Object.getOwnPropertyNames(b.prototype).filter((t=>b.prototype[t]instanceof Function)).map((t=>b.prototype[t])));let E=b;window.BrizyLibs=e})();